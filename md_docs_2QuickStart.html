<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vulkan2D: Vulkan2D Quickstart</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Vulkan2D
   </div>
   <div id="projectbrief">2D renderer written in C using Vulkan and SDL2</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_docs_2QuickStart.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Vulkan2D Quickstart</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md4"></a>Vulkan2D (VK2D) is a 2D/3D renderer written in C with Vulkan for small 2D games. It is simple enough to use, but of course there is this guide to help with some of the details.</p>
<ul>
<li>The Basics</li>
<li>Drawing</li>
<li>Textures</li>
<li>Polygons</li>
<li>Cameras</li>
<li>Models</li>
<li>Shaders</li>
</ul>
<h1><a class="anchor" id="autotoc_md5"></a>
The Basics</h1>
<p>Everything that will be mentioned in this guide is mentioned in greater detail in the documentation for any given function. Feel free to generate the doxygen docs or simply read the header file containing the function for more information. The functions of interest to the average user will be <code>vk2dRenderer*</code>, <code>vk2dTexture*</code>, <code>vk2dPolygon*</code>, <code>vk2dCamera*</code>, <code>vk2dModel*</code>, and <code>vk2dShader*</code>.</p>
<p>Controlling the renderer is quite simple and only requires a few things:</p>
<ul>
<li>Initialize it at the start of your program with <code>vk2dRendererInit</code></li>
<li>Call <code>vk2dRendererStartFrame</code> each frame before you start drawing</li>
<li>Call <code>vk2dRendererEndFrame</code> at the end of each frame to finish drawing that frame</li>
<li>Once your program is done, use <code>vk2dRendererQuit</code> (but make sure to call <code>vk2dRendererWait</code> before freeing any VK2D resources)</li>
</ul>
<p>Outside of those basics, there is a lot you can do with the renderer. Here are some of the more interesting functions with a basic explanation:</p>
<ul>
<li><code>vk2dRendererSetConfig</code> lets you change renderer configuration whenever you want</li>
<li><code>vk2dRendererSetBlendMode</code> will change the current blend mode letting you do cool effects like lighting</li>
<li><code>vk2dRendererSetColourMod</code> changes the colour modifier which is applied to most drawing functions, you could set something like <code>[1, 0.5, 0.5, 1]</code> to make everything more red</li>
<li><code>vk2dRendererGetAverageFrameTime</code> returns the average amount of time taken between start and end of each frame</li>
<li><code>vk2dRendererGetLimits</code> returns a structure containing information on what the user's machine is capable of</li>
</ul>
<h1><a class="anchor" id="autotoc_md6"></a>
Drawing</h1>
<p>Drawing in VK2D is done through the renderer, the draw functions at the time of writing are</p>
<ul>
<li><code>vk2dRendererDrawRectangle</code> - Draws filled rectangles with the current render colour modifier</li>
<li><code>vk2dRendererDrawRectangleOutline</code> - Draws rectangle outlines with the current render colour modifier</li>
<li><code>vk2dRendererDrawCircle</code> - Draws filled circles with the current render colour modifier</li>
<li><code>vk2dRendererDrawCircleOutline</code> - Draws circle outlines with the current render colour modifier</li>
<li><code>vk2dRendererDrawLine</code> - Draws a line with the current render colour modifier</li>
<li><code>vk2dRendererDrawTexture</code> - Draws a texture</li>
<li><code>vk2dRendererDrawShader</code> - Draws a texture using a user-provided shader</li>
<li><code>vk2dRendererDrawPolygon</code> - Draws a polygon</li>
<li><code>vk2dRendererDrawGeometry</code> - Draws a list of vertices without the need for a <code>VK2DPolygon</code></li>
<li><code>vk2dRendererDrawModel</code> - Draws a 3D model</li>
<li><code>vk2dRendererAddBatch</code> - Queues many <code>vk2dRendererDrawTexture</code>s at once, useful for multi-threading or just more control</li>
</ul>
<p>They all also have some macros to make them a little less cumbersome to use. Check the documentation for more details on each one, as only some of the FAQ stuff will be covered here.</p>
<p>In VK2D, coordinates start at the top-left of the screen and go left-to-right.</p>
<div class="image">
<img src="screenspace.png" alt=""/>
<div class="caption">
image</div></div>
    <p>In effect, something drawn with a y-value of 300 will be further down the display than something drawn with a y-value of 100. This means the y-axis is opposite to how you might be used to it in math - it will make more sense when you start working with it. The x-axis is "normal" though.</p>
<p>Rotation is always done with radians in VK2D and all rotation follow the same pattern:</p>
<div class="image">
<img src="rotations.png" alt=""/>
<div class="caption">
image</div></div>
    <p>All rotations start from what would be East on a compass and go clockwise. In addition, a texture/rectangle origin of 0/0 represents the top-left corner just like screen space. This means that if you were to take a texture such as</p>
<div class="image">
<img src="rotationexample1.png" alt=""/>
<div class="caption">
image</div></div>
    <p>and rotate by half of pi, you would get</p>
<div class="image">
<img src="rotationexample2.png" alt=""/>
<div class="caption">
image</div></div>
    <p>(It moved to the side.)</p>
<p>If you were to set the origin to half of the texture's width and height, you would instead get</p>
<div class="image">
<img src="rotationexample3.png" alt=""/>
<div class="caption">
image</div></div>
    <p>Notice how it rotated in place instead of moving to the side.</p>
<p>By default, circle's origins are at their center, however. 3D models play by completely different rules defined by your models and however your 3D cameras are set up.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
Textures</h1>
<p>Textures are the primary way of drawing images to the screen. You can load textures with <code>vk2dTextureLoad</code> and <code>vk2dTextureFrom</code>, then draw them however you want. More interestingly, you can create textures to render to with <code>vk2dTextureCreate</code>. Textures created this way can be rendered to in the same way you would draw to the screen, just call <code>vk2dRendererSetTarget</code> on it then you can render whatever you want to the texture. This is useful when you want to render a lot of something once, then just display that instead of rendering a lot of it every frame. Some common pitfalls to avoid here are:</p>
<ul>
<li>Textures are stored in VRAM, and you have limited amounts of it</li>
<li>Textures must be drawn to completely before rendering them, usually you may simply use <code>vk2dRendererEmpty</code> after setting the render target to a texture - failure to do so <em><b>will</b></em> cause crashes on certain hardware without warning</li>
<li>You may only render textures created this way when they are not the current render target (switch back to <code>VK2D_TARGET_SCREEN</code> before drawing a target texture)</li>
</ul>
<p>Additionally, texture targets have a coordinate space identical to that of the screen by default - the origin is the top-left and the y-axis goes down. You may use <code>vk2dRendererSetTextureCamera</code> to use user-defined cameras on texture targets instead of their default texture space. This still has the side effect of ignoring the cameras' <code>xOnScreen</code>, <code>yOnScreen</code>, <code>wOnScreen</code>, and <code>hOnScreen</code> parameters because the viewport will simply be set to the texture's dimensions.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
Sprite Batching</h2>
<p>Strongly related to drawing textures is sprite-batching. As of right now, only textures are batched automatically, meaning drawing textures is heavily hardware-accelerated to be as fast as possible since that's probably what 90% of your drawing will be in a game. To better make use of this feature, try to keep as much texture drawing together as possible, since everytime you use a draw command other than <code>vk2dRendererDrawTexture</code> the current batch is flushed. Alternatively, you may just build your own list of <code><a class="el" href="structVK2DDrawCommand.html" title="Represents a user&#39;s draw command which will later be processed into an instance.">VK2DDrawCommand</a></code>s and submit them with <code>vk2dRendererAddBatch</code> as to give yourself complete control over when your sprite batch is submitted. This, however, is a very minor optimization and in general even blatantly disregarding this feature will still result in good performance as most of the heavy lifting will be done on the GPU all the same.</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Polygons</h1>
<p>VK2D provides a few drawing primitives, but if you want more detailed shapes, you may load your own with <code>vk2dPolygonShapeCreateRaw</code> and <code>vk2dPolygonCreate</code>. <code>vk2dPolygonShapeCreateRaw</code> lets you specify your own vertices with specified colours, but the input must be triangulated; the example in <code>examples/main</code> does this. <code>vk2dPolygonCreate</code> lets you create arbitrary polygons with just a list of <code>vec2</code>'s, and will automatically triangulate the input. Polygons created with <code>vk2dPolygonCreate</code> will be solid white and their colour can be modified by changing the renderer's colour modifier.</p>
<h1><a class="anchor" id="autotoc_md10"></a>
Cameras</h1>
<p>Cameras are a way to look into the game world with lots of powerful features. You may create up to a certain number of cameras yourself, and by default the renderer will render to all of them at once to allow for things like mini-maps or split-screen (see the split-screen example in <code>examples/</code> for implementation details). You may also use <code>vk2dRendererLockCameras</code> to force the renderer to only render to a specific camera.</p>
<p>The first camera is always reserved for the renderer, you may refer to it as <code>VK2D_DEFAULT_CAMERA</code> and while you may update it, its recommended to leave it for UI drawing because it will be changed by the renderer without warning whenever the window is resized.</p>
<p>To create and use a camera, you need a camera specification (<code><a class="el" href="structVK2DCameraSpec.html" title="Camera information.">VK2DCameraSpec</a></code>) and camera index (<code>VK2DCameraIndex</code>). The spec is how you provide the renderer with the data it needs to render your world, and the index is how you keep track of the cameras you make. Most of the spec parameters are simple and well documented, we will use some examples will be used.</p>
<p>In the images below the black border represents what part of the game world the camera is viewing.</p>
<div class="image">
<img src="cameraexample-1.png" alt=""/>
<div class="caption">
image</div></div>
    <p>Cameras simply view a portion of the game world. You may do things like rotate the camera, zoom in, and move it.</p>
<div class="image">
<img src="cameraexample-2.png" alt=""/>
<div class="caption">
image</div></div>
    <p>The 4 fields, <code>xOnScreen</code>, <code>yOnScreen</code>, <code>wOnScreen</code>, and <code>hOnScreen</code> control the viewport for the camera. This means <code>xOnScreen</code> and <code>yOnScreen</code> controls the x and y position in the game window where the camera will be displayed from and <code>wOnScreen</code> and <code>hOnScreen</code> controls the width and height of the camera in the game window. <code>wOnScreen</code> and <code>hOnScreen</code> are completely independent from the cameras <code>w</code> and <code>h</code> variables; you may have a camera with <code>w</code> and <code>h</code> much smaller than <code>wOnScreen</code> and <code>hOnScreen</code>, in fact the example in <code>examples/retrolook</code> does exactly that.</p>
<div class="image">
<img src="cameraexample-3.png" alt=""/>
<div class="caption">
image</div></div>
    <h1><a class="anchor" id="autotoc_md11"></a>
Models</h1>
<p>Models are a way of drawing 3D models, and they are loaded in similar fashion to Polygons. You may load a model from vertices using <code>vk2dModelCreate</code>, which also expects that the input be triangulated. You may load models from a .obj file using <code>vk2dModelLoad</code> or <code>vk2dModelFrom</code>. All models are expected to be UV mapped and you must provide the texture yourself.</p>
<p>To actually draw the 3D models, you need a 3D camera. Cameras in general were described above but some specifics for 3D will be discussed here</p>
<ul>
<li>3D cameras must have the type <code>VK2D_CAMERA_TYPE_PERSPECTIVE</code> or <code>ct_Orthogonal</code> for VK2D to actually render 3D models to them</li>
<li>Cameras with the type <code>VK2D_CAMERA_TYPE_DEFAULT</code> will simply not have 3D models drawn to them even if you call <code>vk2dRendererDrawModel</code> with the renderer locked to such cameras</li>
<li>The camera spec parameters <code>x</code>, <code>y</code>, <code>w</code>, <code>h</code>, <code>zoom</code>, and <code>rot</code> are ignored for 3D cameras in favour of the parameters in <code>VK2DCameraSpec.Perspective.*</code></li>
</ul>
<p>The example <code>examples/retrolook</code> shows a very simple setup and usage of a 3D camera, and the example <code>examples/main</code> has a 3D camera moving with the mouse.</p>
<h1><a class="anchor" id="autotoc_md12"></a>
Shaders</h1>
<p>You may provide your own SPIR-V compiled shaders to render textures with. For a detailed example check <code>examples/main</code>.</p>
<p>Shaders may be loaded with <code>vk2dShaderLoad</code> and <code>vk2dShaderFrom</code>, and if you specify a buffer size other than 0 you must provide <code>vk2dRendererDrawShader</code> with a data buffer of at least that size. For some specifics,</p>
<ul>
<li>Your shaders must have the same inputs and outputs as the shader in <code>assets/test.frag</code>/<code>assets/test.vert</code></li>
<li>Shader buffer size must be a multiple of 4</li>
<li>To specify a uniform buffer, you must specify the size when you create the shader and use</li>
</ul>
<p>The fragment shader should have the following information before the main entry point:</p>
<div class="fragment"><div class="line">#version 450</div>
<div class="line">#extension GL_ARB_separate_shader_objects : enable</div>
<div class="line">#extension GL_EXT_scalar_block_layout : enable</div>
<div class="line">#extension GL_EXT_nonuniform_qualifier : enable</div>
<div class="line"> </div>
<div class="line">// VK2D provided variables</div>
<div class="line">layout(push_constant) uniform PushBuffer {</div>
<div class="line">    int cameraIndex;</div>
<div class="line">    uint textureIndex;</div>
<div class="line">    vec4 texturePos;</div>
<div class="line">    vec4 colour;</div>
<div class="line">    mat4 model;</div>
<div class="line">} push;</div>
<div class="line"> </div>
<div class="line">layout(set = 0, binding = 0) uniform UniformBufferObject {</div>
<div class="line">    mat4 viewproj[10];</div>
<div class="line">} ubo;</div>
<div class="line"> </div>
<div class="line">layout(set = 1, binding = 1) uniform sampler texSampler;</div>
<div class="line">layout(set = 2, binding = 2) uniform texture2D tex[];</div>
<div class="line"> </div>
<div class="line">// Input from the vertex shader</div>
<div class="line">layout(location = 1) in vec2 fragTexCoord;</div>
<div class="line">layout(location = 2) in vec4 fragColour;</div>
<div class="line"> </div>
<div class="line">// Output of the fragment shader</div>
<div class="line">layout(location = 0) out vec4 outColor;</div>
<div class="line"> </div>
<div class="line">// Optional user-provided uniform buffer</div>
<div class="line">layout(set = 3, binding = 3) uniform UserData {</div>
<div class="line">    float colour;</div>
<div class="line">} userData;</div>
<div class="line"> </div>
<div class="line">void main() {</div>
<div class="line">    // your code here</div>
<div class="line">}</div>
</div><!-- fragment --><p>And for the vertex shader:</p>
<div class="fragment"><div class="line">#version 450</div>
<div class="line">#extension GL_ARB_separate_shader_objects : enable</div>
<div class="line"> </div>
<div class="line">// Required for VK2D</div>
<div class="line">const vec2 VERTICES[] = {</div>
<div class="line">    vec2(0.0f, 0.0f),</div>
<div class="line">    vec2(1.0f, 0.0f),</div>
<div class="line">    vec2(1.0f, 1.0f),</div>
<div class="line">    vec2(1.0f, 1.0f),</div>
<div class="line">    vec2(0.0f, 1.0f),</div>
<div class="line">    vec2(0.0f, 0.0f),</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">const vec2 TEX_COORDS[] = {</div>
<div class="line">    vec2(0.0f, 0.0f),</div>
<div class="line">    vec2(1.0f, 0.0f),</div>
<div class="line">    vec2(1.0f, 1.0f),</div>
<div class="line">    vec2(1.0f, 1.0f),</div>
<div class="line">    vec2(0.0f, 1.0f),</div>
<div class="line">    vec2(0.0f, 0.0f),</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">layout(push_constant) uniform PushBuffer {</div>
<div class="line">    int cameraIndex;</div>
<div class="line">    uint textureIndex;</div>
<div class="line">    vec4 texturePos;</div>
<div class="line">    vec4 colour;</div>
<div class="line">    mat4 model;</div>
<div class="line">} push;</div>
<div class="line"> </div>
<div class="line">layout(set = 0, binding = 0) uniform UniformBufferObject {</div>
<div class="line">    mat4 viewproj[10];</div>
<div class="line">} ubo;</div>
<div class="line"> </div>
<div class="line">// Output to the fragment shader</div>
<div class="line">layout(location = 0) out vec4 gl_Position;</div>
<div class="line">layout(location = 1) out vec2 fragTexCoord;</div>
<div class="line">layout(location = 2) out vec4 fragColour;</div>
<div class="line"> </div>
<div class="line">// Optional user-provided uniform buffer</div>
<div class="line">layout(set = 3, binding = 3) uniform UserData {</div>
<div class="line">    float colour;</div>
<div class="line">} userData;</div>
<div class="line"> </div>
<div class="line">void main() {</div>
<div class="line">    // your code here</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
